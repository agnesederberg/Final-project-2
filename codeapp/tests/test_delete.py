import logging

from flask import url_for
from sqlalchemy import func, select
from sqlalchemy.sql.expression import Select

from codeapp import db
from codeapp.models import Folder, Note, User
from codeapp.tests.test_user import TestUser

from .utils import TestCase


class TestDelete(TestCase):
    """
    This class must implement the test cases related to the delete use case.
    Implement as many methods as needed to cover 100% of the code.
    """

    def test_delete_success(self) -> None:
        """
        This function tests if the delete route is working correctly.
        """
        # first, get an object from the database
        # you can adjust the filtering to get the object you want
        # remember to add the imports
        # statement: Select = select(<your table here>).limit(1)
        # one: Type = db.session.execute(statement).scalars().one()

        # then, make the delete request
        # response = self.client.post(
        #     url_for("bp.<function name>", <obj id>=<one.id>),
        #     data={<data here in the form of a dictionary>},
        #     follow_redirects=True,
        # )
        # self.assert200(response)
        # self.assertTemplateUsed("<template name>.html")
        # self.assertIn("<expected error message>", response.data.decode())

        # the delete request usually redirects the user to some other page
        # self.assertRedirects(
        #     response,
        #     url_for("bp.<function where the user should be redirected to>")
        # )
        # self.assert_html(response)

        # first, get an object from the database
        # you can adjust the filtering to get the object you want
        # remember to add the imports
        # statement: Select = select(<your table here>).filter_by(id=one.id)
        # one: Type = db.session.execute(statement).scalars().one()
        # make sure that the object does not exist anymore
        # assert one is None, f"The object {one} was not deleted successfully!"

    def test_delete_exception(self) -> None:
        """
        This function tests if the system is behaving correctly when the database
        raises an exception.
        The exception is generated by mocking the session object.
        """
        # first, get an object from the database
        # you can adjust the filtering to get the object you want
        # remember to add the imports
        # statement: Select = select(<your table here>).limit(1)
        # one: Type = db.session.execute(statement).scalars().one()

        # now you mock the session
        # with patch(
        #     "codeapp.routes.db.session.commit",
        #     side_effect=ValueError("Mock error"),
        #     autospec=True,
        #     spec_set=True,
        # ) as mock_commit:
        #     # then, make the delete request
        #     response = self.client.post(
        #         url_for("bp.<function name>", <obj id>=<one.id>),
        #         data={<data here in the form of a dictionary>},
        #         follow_redirects=True,
        #     )
        #     self.assert200(response)
        #     self.assertTemplateUsed("<template name>.html")
        #     self.assertIn(
        #         "<expected error message>",
        #         response.data.decode()
        #     )

        #     the delete request usually redirects the user to some other page
        #     self.assertRedirects(
        #         response,
        #         url_for("bp.<function where the user should be redirected to>")
        #     )
        #     self.assert_html(response)

    def test_delete_folder(self) -> None:
        # the user needs to be logged in
        temp = self.client.post(
            url_for("bp.login"),
            data={"email": TestUser.username, "password": TestUser.password},
            follow_redirects=True,
        )
        self.assertTemplateUsed("home.html")
        self.assertMessageFlashed("Welcome!", "success")

        # get the user id
        statement: Select = select(User).filter_by(email=TestUser.username)
        user: User = db.session.execute(statement).scalars().one()

        # find a folder to delete
        folder_deletion: Select = (
            select(Folder).filter_by(user_id=user.id).order_by(func.random()).limit(1)
        )
        folder: Folder = db.session.execute(folder_deletion).scalars().one()

        # delete the folder
        response = self.client.post(
            url_for("bp.delete_folder"),
            json={
              "folderId": folder.id,
            },
            follow_redirects=True,
        )

        self.assert200(response)
        self.assertTemplateUsed("folders.html")
        self.assertIn(
            "Folder deleted!",
            response.data.decode(),
        )

    def test_delete_note(self) -> None:
        # Loggin in
        temp = self.client.post(
            url_for("bp.login"),
            data={"email": TestUser.username, "password": TestUser.password},
            follow_redirects=True,
        )
        self.assertTemplateUsed("home.html")
        self.assertMessageFlashed("Welcome!", "success")

        # get the user id
        statement: Select = select(User).filter_by(email=TestUser.username)
        user: User = db.session.execute(statement).scalars().one()

        # find a folder to delete note from
        folder_deletion: Select = (
            select(Folder).filter_by(user_id=user.id).order_by(func.random()).limit(1)
        )
        folder: Folder = db.session.execute(folder_deletion).scalars().one()

        # select note to delete
        note_deletion: Select = (
            select(Note).filter_by(folder_id=folder.id).order_by(func.random()).limit(1)
        )
        note: Note = db.session.execute(note_deletion).scalars().one()

        # delete the note
        response = self.client.post(
            url_for("bp.delete_note"),
            json={
                "noteId": note.id,
            },
            follow_redirects=True,
        )

        self.assert200(response)
        self.assertTemplateUsed("notes.html")
        self.assertIn(
            "Note deleted!",
            response.data.decode(),
        )


if __name__ == "__main__":
    logging.fatal("This file cannot be run directly. Run `pytest` instead.")
